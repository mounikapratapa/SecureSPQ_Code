from miller_rabin_test import is_prime
import random
import sys
sys.setrecursionlimit(100)
def generate_prime_candidate(size):
    p = random.getrandbits(size)
    p |= (1 << size - 1) | 1
    return p
def generate_prime_numbers(size):
    p = 4
    while not is_prime(p):
        p = generate_prime_candidate(size)
    return p
def gcd(a, b):
    while b:
        return gcd(b, a%b)
    return a
def egcd(a, b):
    u, u1 = 1, 0
    v, v1 = 0, 1
    g, g1 = a, b
    while g1:
        q = g // g1
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        g, g1 = g1, g - q * g1
    return u, v, g
def modinv(a, m):
    x, y,g = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

def L(x, p):
    return ((x-1) // p)
def keys(size):
    #p=   425050889313652378906344655877606807618480437358986449425186169237406479047694133365035338151922637686293991623754780820838303596719487914187297781486500122555821183420677961449919044304374412942385999228228038206375338883661425194878092442700101842023553145502337794864900334723335896155554139386683540404456896667358356246986242672717708626654279742007228014975393729749816682699527180453716003588951344596121050383088388464798009732149404416407345949033601152661464043822588917209591193844744643882955355460499796127553202664430883840963550279726831773039700195129599546355221592461319448233973059343035935490788758637709683440520561996637393798512844436172244086276916942144280002653796514466016114760362022388465455493342099999205394879828455701203142186244778366655443187061429639787586372955672032132121382368858561950648380283780137760641117284904399125908234960811600518671573108375659726793280934500324753188060204948892783678285313043798288154779476739286198637740425154537823885026871982088248715180305139971910459349654960114446609916742847309611368326012009740995871317350013134640677962366864052569531171667714700039699541125100835223779370308979104449499623128553089400609388812604406615571852589081015876428613197783362807851342444536985334727144862541623272314012788074593903047673026952684183015290883278591043940688334650199552918498410214870720630982016281663903304363576091214818217992412124319703310942443037720678032186014748089641686641478326688980943976824339138410498186575391189996218692360691896928249019039544582753875551982183991068388815508185600391761114030783396531379756826277981302797650150600937174701625697743635040408912657400764216809449060834453782130749157518938911923099255668790041230764458450494417917628292975899148993161234097014766533588003981848862653982076977465502075768621640371107399095104455077953167926487660894578107236242613766473956358167921072574093742353566444273571104178621386960822141935974607343374386658068496583829599036126504339500940374003230363938985897209533264380753359543273957517885778023568352601067794101864013341972455320052966323958434614590962332615717
    #p = 182939421825860730948795554347253710433341720746097250017330088724340554109010106389034043901594265130206894670613851113639159467375323931564746868596376328468275389227573712850249120910065615922753047795279261657486238668215474147668353754280330692644926893915798266897830632964878067526700972649960064952132112063177
    #p=    149721637597453
    p = 70404470836673456642937968870480997199552877944781723511551237182454544842985007390607138146394452777

    q = generate_prime_numbers(size)
    assert p != q
    n =  p*p*q
    while True:
        x =  random.randint(23,n)
        g = pow(x, p-1, p**2)
        if g != 1:
            break
    return((n, g), (p, q))
    
def enc(pk,s):
    pt = s
    n,g = pk
    r = random.randint(23,n)
    ct = pow(g, (pt+(n *r)), n)
    return ct

def dec(sk,g,ct):
    p,q = sk
    x1 = pow(ct, p-1, p**2)
    x2 = pow(g, p-1, p**2)
    L1 = L(x1,p)
    #print(L1)
    L2 = modinv(L(x2,p),p)
    message = (L1* L2) % p
    s = message
    return s
'''def main():
    pk, sk = keys(10)
    n,g = pk
    print(pk, sk)
    disp = input("Do you want to test for homomorphism?(y/n):")
    if(disp == 'y'):
        print("Good choice,let us have some fun!")
        p1 = input("Enter the first integer:")
        p2 = input("Enter the second integer:")
        c1 = enc(pk,int(p1))
        c2 = enc(pk,int(p2))
        c3 = pow(c1,2,n)
        c3 = c3*c2
        print("Your first cipher text is:",c1)
        print("Your second cipher text is:",c2)
        print("cipher product is:", c3)
        print("Decrypting")
        message = dec(sk,g, c3)
        print(message)
        d = input("Is this less than or equal to plain m1 + m2?(y/n):")
        if(d == 'y'):
            print("Eureka!")
        else:
            print("Okamoto_Uchiyama Failed!")
    else:    
        pt = input("Enter the integer you want to encrypt:")
        print("Encrypting...")
        ct = enc(pk,int(pt))
        print("Your cipher text is:",ct)
        print("Decrypting...")
        message = dec(sk,g,ct)
        print("Here is the secret in plain text:", message)
   
main()
'''    
    